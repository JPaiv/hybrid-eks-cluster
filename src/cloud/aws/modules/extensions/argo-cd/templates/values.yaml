crds:
  # -- Install and upgrade CRDs
  install: true
  # -- Keep CRDs on chart uninstall
  keep: false

global:
  domain: ${domain}

# -- External Elasticache Redis parameters
externalRedis:
  host: ${redis_host}
  password: ${redis_password}
  port: "${redis_port}"

controller:
  replicas: 2
  serviceAccount:
    create: true
    labels:
      app.kubernetes.io/component: argo-cd
      app.kubernetes.io/instance: controller
      app.kubernetes.io/managed-by: Tofu-Helm
      app.kubernetes.io/name: ${id_label}
      app.kubernetes.io/part-of: ci-cd
      app.kubernetes.io/stage: ${stage}
      app.kubernetes.io/version: ${chart_version}
  resources:
    requests:
      cpu: 200m
      memory: 200Mi
    limits:
      cpu: 1000m
      memory: 1000Mi

# -- General Argo CD configuration.
# --Any values you put under `.configs.cm` are passed to argocd-cm ConfigMap.
configs:
  # -- The argocd-cm configmap
  # Ref: https://github.com/argoproj/argo-cd/blob/master/docs/operator-manual/argocd-cm.yaml
  cm:
    create: true
    admin.enabled: true
    accounts.devops: apiKey, login
    oidc.config: |
      name: Authentik
      clientID: ${authentik_cli_id}
      clientSecret: ${authentik_cli_secr}
      issuer: ${issuer_url}
      requestedScopes:
        - email
        - groups
        - openid
        - profile
      requestedIDTokenClaims:
        groups:
          essential: true
  secret:
    createSecret: true
    labels:
      app.kubernetes.io/component: argo-cd
      app.kubernetes.io/managed-by: Tofu-Helm
      app.kubernetes.io/name: ${id_label}
      app.kubernetes.io/part-of: ci-cd
      app.kubernetes.io/stage: ${stage}
      app.kubernetes.io/version: ${chart_version}
    # -- Password must be bcrypt hashed
    # -- python3 -c "import string, random, bcrypt; length=20; chars=string.ascii_letters + string.digits; password=''.join(random.choices(chars, k=length)); hashed_pw=bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8'); print(f'Plaintext Password:\n{password}\n\nHashed for Helm/YAML:\n{hashed_pw}')"
    argocdServerAdminPassword: ${admin_pass}
  rbac:
    create: true
    policy.default: role:readonly
    # -- Role definitions and bindings are in the form:
    # -- g, subject, inherited-subject
    policy.csv: |
      g, devops, role:admin
      p, role:org-admin, applications, *, */*, allow
      p, role:org-admin, clusters, get, *, allow
      p, role:org-admin, exec, create, */*, allow
      p, role:org-admin, logs, get, *, allow
      p, role:org-admin, repositories, *, *, allow
    scopes: "[groups, email, repositories]"

repoServer:
  replicas: 2
  autoscaling:
    enabled: true
    maxReplicas: 10
    minReplicas: 2
    targetCPUUtilizationPercentage: 50
    targetMemoryUtilizationPercentage: 50
  serviceAccount:
    create: true
    labels:
      app.kubernetes.io/component: argo-cd
      app.kubernetes.io/instance: repoServer
      app.kubernetes.io/managed-by: Tofu-Helm
      app.kubernetes.io/name: ${id_label}
      app.kubernetes.io/part-of: ci-cd
      app.kubernetes.io/stage: ${stage}
      app.kubernetes.io/version: ${chart_version}
  resources:
    limits:
      cpu: 1000m
      memory: 1000Mi
    requests:
      cpu: 200m
      memory: 200Mi

# -- Kubernetes controller for the Argo-CD ApplicationSet CRD
applicationSet:
  replicas: 2
  serviceAccount:
    create: true
    labels:
      app.kubernetes.io/component: argo-cd
      app.kubernetes.io/managed-by: Tofu-Helm
      app.kubernetes.io/name: ${id_label}
      app.kubernetes.io/part-of: ci-cd
      app.kubernetes.io/stage: ${stage}
      app.kubernetes.io/version: ${chart_version}
  resources:
    requests:
      cpu: 100m
      memory: 100Mi
    limits:
      cpu: 1000m
      memory: 1Gi

# -- Argo-CD monitor to notify changes in application state.
notifications:
  resources:
    limits:
      cpu: 1000m
      memory: 1000Mi
    requests:
      cpu: 200m
      memory: 200Mi
  # -- Notifications controller log format
  # -- One of: `text` or `json`
  logFormat: json
  # -- Notifications controller log level.
  # -- One of: `debug`, `info`, `warn`, `error`
  logLevel: info

# -- gRPC/REST Server to consume WebUI, CLI and CI/CD commands
# -- Runs in the foreground
server:
  replicas: 2
  autoscaling:
    enabled: true
    maxReplicas: 10
    minReplicas: 2
    targetCPUUtilizationPercentage: 50
    targetMemoryUtilizationPercentage: 50
  resources:
    limits:
      cpu: 1000m
      memory: 1Gi
    requests:
      cpu: 200m
      memory: 200Mi
  service:
    create: true
    labels:
      app.kubernetes.io/component: argo-cd
      app.kubernetes.io/instance: server
      app.kubernetes.io/managed-by: Tofu-Helm
      app.kubernetes.io/name: ${id_label}
      app.kubernetes.io/part-of: ci-cd
      app.kubernetes.io/stage: ${stage}
      app.kubernetes.io/version: ${chart_version}
  serviceAccount:
    create: true
    name: ${irsa_name}
    annotations:
      eks.amazonaws.com/role-arn: ${irsa_arn}
    labels:
      app.kubernetes.io/component: argo-cd
      app.kubernetes.io/instance: server
      app.kubernetes.io/managed-by: Tofu-Helm
      app.kubernetes.io/name: ${id_label}
      app.kubernetes.io/part-of: ci-cd
      app.kubernetes.io/stage: ${stage}
      app.kubernetes.io/version: ${chart_version}
  ingress:
    enabled: true
    ingressClassName: alb
    hosts:
      - ${domain}
    tls:
      - hosts:
          - ${domain}
    annotations:
      alb.ingress.kubernetes.io/actions.ssl-redirect: '{"Type": "redirect", "RedirectConfig": { "Protocol": "HTTPS", "Port": "443", "StatusCode": "HTTP_301"}}'
      alb.ingress.kubernetes.io/backend-protocol: HTTPS
      alb.ingress.kubernetes.io/healthcheck-interval-seconds: "30"
      alb.ingress.kubernetes.io/healthcheck-path: /healthz
      alb.ingress.kubernetes.io/healthcheck-protocol: HTTPS
      alb.ingress.kubernetes.io/listen-ports: '[{"HTTPS":443}, {"HTTP":80}]'
      alb.ingress.kubernetes.io/load-balancer-attributes: routing.http2.enabled=true
      alb.ingress.kubernetes.io/load-balancer-name: ${id_label}
      alb.ingress.kubernetes.io/scheme: internet-facing
      alb.ingress.kubernetes.io/ssl-policy: ELBSecurityPolicy-FS-1-2-2019-08
      alb.ingress.kubernetes.io/success-codes: 200,404
      alb.ingress.kubernetes.io/tags: stage=${stage},cluster=${eks_cluster_id},team=devops,owner=ums-devops,tofu=true,helm=true,manifest=false
      alb.ingress.kubernetes.io/target-type: ip
    labels:
      app.kubernetes.io/component: argo-cd
      app.kubernetes.io/instance: server
      app.kubernetes.io/managed-by: Tofu-Helm
      app.kubernetes.io/name: ${id_label}
      app.kubernetes.io/part-of: ci-cd
      app.kubernetes.io/stage: ${stage}
      app.kubernetes.io/version: ${chart_version}
  ingressGrpc:
    enabled: true
    isAWSALB: true
    awsALB:
      serviceType: ClusterIP
      backendProtocolVersion: GRPC
    hosts:
      - ${domain}

# -- Disable default self-hosted Redis
redis-ha:
  enabled: false
redis:
  enabled: false
